<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.17" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  
  <title>Bartosz Pietrzak</title>
  

  
  <link rel="stylesheet" href="https://b3k.github.io/css/poole.css">
  <link rel="stylesheet" href="https://b3k.github.io/css/syntax.css">
  <link rel="stylesheet" href="https://b3k.github.io/css/hyde.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://b3k.github.io/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="https://b3k.github.io/favicon.png">

  
  <link href="https://b3k.github.io/index.xml" rel="alternate" type="application/rss+xml" title="Bartosz Pietrzak" />
</head>

<body class="theme-base-0e ">

<div class="sidebar">
  <div class="container sidebar-sticky">
	  <img src="https://b3k.github.io/images/nyan.png" width="100%" />
    <div class="sidebar-about">
      <a href="https://b3k.github.io/"><h1>Bartosz Pietrzak</h1></a>
      <p class="lead">
       Just another boring dev blog. 
      </p>
    </div>

    <ul class="sidebar-nav">
      <li><a href="https://b3k.github.io/">Home</a> </li>
      
      <li><a href="https://github.com/b3k" target="_blank">Github</a></li>
    </ul>

    <p>&copy; 2016. All rights reserved. </p>
  </div>
</div>


    <div class="content container">
<div class="posts">

      
  <div class="post">
    <h1 class="post-title">
      <a href="https://b3k.github.io/posts/cache-in-rest-api-with-varnish-esi/">
        Efficient cache in the REST API using Varnish ESI
      </a>
    </h1>

    <span class="post-date">Sun, Dec 11, 2016</span>

    

<p>Some time ago, while working on a REST API for our corporate applications, approaching the moment when the API was already stabilized we moved on to the optimization - because we expected the API can be used very intensively. Looking for the optimal strategy for the cache, we established the following criteria:</p>

<ul>
<li>Each resource should be generated only once</li>
<li>Resources may have different TTL-s</li>
<li>There is a possibility of precise cache invalidation for a single resource</li>
<li>We do not duplicate the cache</li>
<li>API can return data in both XML and JSON formats</li>
</ul>

<p>After much research we have concluded that the Varnish and its ESI tags are almost ideal.</p>

<h3 id="edge-side-include">Edge-Side Include</h3>

<p>Edge-Side Include (ESI) is proposed by Akamai and Oracle web standard. It allows the server to support this standard for placement in one page content from different URLs.</p>

<p>With ESI we can extract part of the page that should not be caching to a separate request and put the rest to the cache. This granularity allows to increase the &ldquo;cache-hit ratio&rdquo; - the ratio of cached queries to non-cached. Of course, if bigger the &ldquo;cache-hit ratio&rdquo; the page loads faster and the costs are lower.</p>

<pre><code class="language-HTML">&lt;div&gt;
    &lt;strong&gt;Your profile:&lt;/strong&gt;
    &lt;esi:include src=&quot;/user/profile&quot; /&gt;
    &lt;esi:include src=&quot;/user/last_activity&quot; /&gt;
&lt;/div&gt;
&lt;div&gt;
    &lt;strong&gt;Our products:&lt;/strong&gt;    
    &lt;esi:include src=&quot;/products&quot; /&gt;
&lt;/div&gt;
</code></pre>

<p>In this case, we see that the block displaying the section of our site was generated by 3 different URLs content of which has been inserted in place of the call by the ESI tag <code>&lt;esi:include src=&quot;/...&quot; /&gt;</code>.</p>

<p>Of course, just generate such sites is not uncommon, until we use Varnish, by which we are able to define a caching policy separately for each of the enclosed by ESI elements.</p>

<p>For more information about ESI tags in Varnish refer to the official documentation: (<a href="https://www.varnish-cache.org/docs/4.0/users-guide/esi.html">https://www.varnish-cache.org/docs/4.0/users-guide/esi.html</a>) - Basic knowledge of their work and knowledge of Varnish configuration <a href="https://www.varnish-cache.org/docs/4.0/reference/vcl.html">VCL</a> will be necessary to understand the following description of this technique.</p>

<h3 id="esi-tags-rest-api-concept">ESI tags &amp; REST API - concept</h3>

<p>Sample API consists of the following endpoints:</p>

<ul>
<li><code>GET /api/rest/document</code> - for a collection of objects <code>document</code></li>
<li><code>GET /api/rest/document/#{document_id}</code> - for a single object <code>document</code></li>
<li><code>GET /api/rest/attachment</code> - for a collection of objects <code>attachment</code></li>
<li><code>GET /api/rest/attachment/#{attachment_id}</code> - for a single object <code>attachment</code></li>
</ul>

<p>Example response to the request <code>GET /api/rest/document/16629</code> :</p>

<pre><code class="language-xml">&lt;document&gt;
    &lt;id&gt;16629&lt;/id&gt;
    &lt;user_id&gt;478&lt;/user_id&gt;
    &lt;title&gt;Sample documents&lt;/title&gt;
    &lt;attachments&gt;
        &lt;attachment&gt;
            &lt;id&gt;556219&lt;/id&gt;
            &lt;title&gt;Invoice&lt;/title&gt;
            &lt;content&gt;......&lt;/content&gt;
        &lt;/attachment&gt;
        &lt;attachment&gt;
            &lt;id&gt;556220&lt;/id&gt;
            &lt;title&gt;Invoice #2&lt;/title&gt;
            &lt;content&gt;......&lt;/content&gt;
        &lt;/attachment&gt;
    &lt;/attachments&gt;
&lt;/document&gt;
</code></pre>

<p>We can see that the response we get (XML data format is irrelevant) which is an object <code>document</code> along with its attributes and the assigned objects of type <code>attachment</code>.</p>

<p>We can also see that a <code>document</code> addition to the data from your entity also needs to retrieve a list of objects <code>attachment</code> that belong to it. If we put in their place ESI tags that will indicate the endpoint <code>GET /api/rest/attachment/#{attachment_id}</code> we can delegate them to the outer request made by the Varnish.</p>

<p>Inserting ESI tags in places where <code>attachment</code> objects are generated obtain such a structure:</p>

<pre><code class="language-xml">&lt;document&gt;
    &lt;id&gt;16629&lt;/id&gt;
    &lt;user_id&gt;478&lt;/user_id&gt;
    &lt;title&gt;Sample documents&lt;/title&gt;
    &lt;attachments&gt;
        &lt;esi:include src=&quot;/api/rest/attachment/556219&quot; /&gt;
        &lt;esi:include src=&quot;/api/rest/attachment/556220&quot; /&gt;
    &lt;/attachments&gt;
&lt;/document&gt;
</code></pre>

<p>When Varnish will receive a response from the backend server, there will be an additional call of two requests:</p>

<ul>
<li><code>GET /api/rest/attachment/556219</code></li>
<li><code>GET /api/rest/attachment/556220</code></li>
</ul>

<p>Varnish synchronously executes the query after each of these elements one by one. After receipt of each response all of them will be placed in a right place in the code.</p>

<p><img src="http://b3k.pl/varnish-esi/varnish-esi-rest-block.png" alt="REST API with subresources" /></p>

<p>It is worth to emphasize that the ESI requests are synchronous (community edition), thus blocking. Varnish on an ongoing basis will send a content received from the requests of the ESI tags. Each sending of an ESI request blocks whole response.</p>

<p><img src="http://b3k.pl/varnish-esi/varnish-esi.png" alt="Varnsih ESI requests flow" /></p>

<p>So sending a request <code>GET /api/rest/document/16629</code> really made a 3 HTTP requests to the backend, one to generate the resource <code>document</code> and the other two ESI requests to generate the necessary <code>attachment</code> resources. The time client waits for this response is the sum of these 3 requests. Of course, here we take the most pessimistic version - every resource was not previously in the cache - so generation of each of these resources required to send a request to the backend.</p>

<p>This allows to selectively cache each of these resources separately and to invalidate cache only for those elements that actually have changed, leaving the remaining contents.</p>

<h5 id="collections">Collections</h5>

<p>Already knowing the basic concept, we apply the same technique for endpoints that return collections.</p>

<p>Example response to the request <code>GET /api/rest/document</code>:</p>

<pre><code class="language-xml">&lt;collection&gt;
    &lt;document&gt;
        &lt;id&gt;16629&lt;/id&gt;
        ...
    &lt;/document&gt;
    &lt;document&gt;
        &lt;id&gt;16630&lt;/id&gt;
        ...
    &lt;/document&gt;
    ...
&lt;/collection&gt;
</code></pre>

<p>We modify the response and placed in the ESI tags:</p>

<pre><code class="language-xml">&lt;collection&gt;
    &lt;esi:include src=&quot;/api/rest/document/16629&quot; /&gt;
    &lt;esi:include src=&quot;/api/rest/document/16630&quot; /&gt;
    &lt;esi:include src=&quot;/api/rest/document/16631&quot; /&gt;
    &lt;esi:include src=&quot;/api/rest/document/16632&quot; /&gt;
    &lt;esi:include src=&quot;/api/rest/document/16632&quot; /&gt;
&lt;/collection&gt;
</code></pre>

<p>Same as in the case of a single element, Varnish perform requests so long as there is tag ESI.</p>

<p>We have also a case of nested ESI tags, because, as noted earlier request <code>GET /api/rest/document/16629</code> can generate additional request <code>GET /api/rest/attachment/#{id_attachment}</code> to retrieve associated <code>attachment</code> objects. So taking the pessimistic case with a lack of items in the cache, where each document is composed of at least 3 <code>attachment</code> objects - 1 request to <code>GET /api/rest/document</code> internally produces 3 requests 5 times - a total of 15 synchronous HTTP requests.</p>

<p>This is a disadvantage and an advantage at the same time - on the one hand it will generate additional traffic on the backend and on the other it will automatically warm up the cache for multiple items. This can also be read in such a way that by calling 1 request automatically warm up cache for 15 elements.</p>

<p>API designed this way require from developer to implement requesting to a single element, because both the collection and nested objects are in fact the response of a single item endpoint.</p>

<p><img src="http://b3k.pl/varnish-esi/varnish-esi-rest-block-collection.png" alt="REST API collection" /></p>

<h5 id="parallel-esi">Parallel ESI</h5>

<p>It would be very helpful to have asynchronous ESI requesting - much gain in performance of collection pages. But unfortunately today (December 2016) parallel ESI was introduced only in the commercial version Varnish Plus (<a href="https://info.varnish-software.com/blog/varnish-lab-parallel-esi">https://info.varnish-software.com/blog/varnish-lab-parallel-esi</a>) and it does not seem to have it quickly moved to the community version (<a href="https://www.varnish-cache.org/lists/pipermail/varnish-misc/2014-October/024039.html">https://www.varnish-cache.org/lists/pipermail/varnish-misc/2014-October/024039.html</a>).</p>

<p>Here we see as obvious is the difference in parallel building a pages composed of ESI tags:
<img src="http://b3k.pl/varnish-esi/serial-esi.gif" alt="Varnsih ESI requests flow" /><img src="http://b3k.pl/varnish-esi/parallel-esi.gif" alt="Varnsih ESI requests flow" /></p>

<h3 id="esi-tags-rest-api-retrieving-data">ESI tags &amp; REST API - Retrieving Data</h3>

<p>Retrieving the data needed to generate the endpoint content can in some cases be reduced only to extract these data which are necessary to create the resource URL.</p>

<p>In our example when retrieving a collection of <code>document</code> objects, backend must actually retrieve only the primary keys and then generate a &ldquo;template&rdquo; with the ESI tags.</p>

<p>With this solution we reduce the traffic between the database and the application. Also note that once created &ldquo;template&rdquo; for collection endpoint will be saved to the cache, so the next time you request an application and even database will not be used.</p>

<h3 id="esi-tags-rest-api-problems-with-implementation">ESI tags &amp; REST API - Problems with implementation</h3>

<h4 id="json-data-format">JSON data format</h4>

<p>If the API returns data in format different than XML, for example in JSON - Varnish will have problems with parsing ESI tags. To allow Varnish parse such documents in order to search for ESI tags (which are XML nodes) parameter <code>feature=+esi_disable_xml_check</code> must be set in the parameters of the daemon startup.</p>

<pre><code>DAEMON_OPTS=&quot;-a :6081 \
             -T localhost:6082 \
             -f /etc/varnish/default.vcl \
             -S /etc/varnish/secret \
             -s malloc,2GB \
             -p feature=+esi_disable_xml_check&quot;
</code></pre>

<h4 id="handling-errors-in-subresources">Handling errors in subresources</h4>

<p>Sometimes it can lead to a situation where Varnish attempts to get resource of ESI tag that no longer exists - for a single resource that is not a big problem in the case of the collection it may result in that we will have mixed contents of HTML containing the description of the 404 error and JSON content of resource - which results in a syntax error for the whole document.</p>

<p>The problem can be easily solved using the benefits of Varnish VCL. At the moment when Varnish detects response error in ESI subresource we can replace it with our content - in this case -  the empty string.</p>

<pre><code class="language-vcl">sub vcl_recv {

    # Add information about ESI level for each request

    set req.http.X-Varnish-Esi-Level = req.esi_level;
}

sub vcl_backend_response {
    if (beresp.status == 404 || (beresp.status &gt;= 500 &amp;&amp; beresp.status &lt;= 599)) {

        # We check this condition because if we do not ask about ESI resource - we want to display 404 error. We check whether the condition applies ESI tag - if so, call vcl_backend_error.

        if (bereq.http.X-Varnish-Esi-Level &amp;&amp; std.integer(bereq.http.X-Varnish-Esi-Level, 0) &gt; 0) {
            return (abandon);
        }
    }
}

sub vcl_backend_error {
    # To make sure that we behave properly only when we ask about ESI resources

    if (bereq.http.X-Varnish-Esi-Level &amp;&amp; std.integer(bereq.http.X-Varnish-Esi-Level, 0) &gt; 0) {

        # Our empty string will be returned in place of the faulty ESI tag

        synthetic(&quot;&quot;);
        return (deliver);
    }
}
</code></pre>

<h4 id="setting-the-ttl">Setting the TTL</h4>

<p>If we want to set the TTL for each endpoint separately we should pass this information with the HTTP response header and then in <code>vcl_backend_response</code> set the received TTL.</p>

<pre><code class="language-vcl">sub vcl_backend_response {
    if (beresp.http.X-Varnish-Cache-Ttl ~ &quot;^\d+$&quot;) {
        set beresp.ttl = std.duration(regsub(beresp.http.X-Varnish-Cache-Ttl, &quot;^(\d+)$&quot;, &quot;\1s&quot;), 3600s);
    }
}
</code></pre>

<h4 id="tagging-elements-and-cache-invalidation">Tagging elements and cache invalidation</h4>

<p>For precise cache invalidation we should use tags for ESI responses. Tags can be transferred as in the case of TTL - using the  HTTP response headers. It should be remembered that both the collections and individual resources can consist of different models - so you should use the format allowing for the distinction of specific keys for specific models such as:</p>

<pre><code>X-Varnish-Tags: model1(12,14,15,16,17);model2(44,56,57,58,59);
</code></pre>

<p>With headline built this way we are able to easily invalidate cache for a particular resource by the Varnish administration interface:</p>

<pre><code># Ban cache for model &quot;model1&quot; with ID &quot;123&quot;
ban obj.http.X-Varnish-Tags ~ .*model1\(([A-Za-z0-9-_]+,)*123(,[A-Za-z0-9-_]+)*\);.*
</code></pre>

<h3 id="summary">Summary</h3>

<p>This technique has its advantages and disadvantages, however, in the case of our API where endpoints contain many subresources proved to be very efficient.</p>

<p>The implementation is not complicated. Using ESI allows us to divide API into the logical individual elements which can be folded like a blocks.</p>

  </div>
  
</div>
</div>

  </body>
</html>
